<% 
const reviewProgress = {}; 

options.hasSentenceReading = fact.type == 2 || (fact.type == 3 && fact['sentence-reading']);
options.giveFeedback = options.giveFeedback || options.promptType == 'audio-cloze';

let tries = 0;
if(options.promptType == 'audio-cloze') tries = 1;
if(options.tries != null) tries = options.tries;

if(options.noImage == null) options.noImage = state['image-condition'] == 1;

let scoringMethod = 'reading';
let source = options.source || 'normal';
if(source != 'normal') scoringMethod = 'sentence-reading';
if(source == 'full-recall' && options.promptType == 'audio-cloze') scoringMethod = 'cloze-word';
if(source == 'tiered-full-recall' && options.promptType == 'audio-cloze') scoringMethod = 'cloze-word';
if(options.scoringMethod) scoringMethod = options.scoringMethod;
%>
<% include partial/review-progress %>
<html>
<head>
	<title>(まだ<%= reviewProgress.nowReviews %>枚) 繰り返すの復習</title>
	<%- include('partial/head') %>
	<link rel="stylesheet" type="text/css" href="/css/review.css">

	<script src="/js/speech-recognizer.js"></script>
	<script src="/js/text-selection.js"></script>

	<link rel="apple-touch-icon" sizes="120x120" href="/icons/joshua-dot/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/icons/joshua-dot/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/icons/joshua-dot/favicon-16x16.png">
	<link rel="manifest" href="/icons/joshua-dot/site.webmanifest">
	<link rel="mask-icon" href="/icons/joshua-dot/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/icons/joshua-dot/favicon.ico">
	<meta name="msapplication-TileColor" content="#00a300">
	<meta name="msapplication-config" content="/icons/joshua-dot/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">

	<script type="text/javascript">
		const targetId = '<%= fact.id %>';
		const originalText = '<%= fact.sentence %>';
		let start = new Date().getTime();
		let results = {};

		let tries = <%= tries %>;

		// 0: input hidden, text visible
		// 1: input visible, text hidden
		// 2: waiting for response
		// 3: waiting for audio
		let state = 0;
		const BeginInput = 1;
		const SubmitInput = 2;
		const AwaitingAudioState = 3;
		const DoneState = 4;
		const BeginSpeech = 5;
		const AwaitingSpeech = 6;
		const AfterBeginInput = <%= options.useSpeechInput ? 'BeginSpeech' : 'BeginInput' %>;
		const ignore = "、…。！？～";

		let clozeWord = '<%= options.clozeWord %>';
		let chunks = [];
		let chunkToReading = {};
		let chunkReadStart = 0;
		let chunkReadTimes = [];
		let chunkIndex = 0;
		<% if(options.chunks) { %>
		chunks = <%- JSON.stringify(options.chunks) %>;
		<% } %>
		<% if(options.chunkToReading) { %>
		chunkToReading = <%- JSON.stringify(options.chunkToReading) %>;
		<% } %>

		let setCorrectColor = () => {
			$("body").css('background-color', 'lightgreen');
		};

		let setWrongColor = () => {
			$("body").css('background-color', 'pink');
		};

		const showError = (text) => {
			$(".error").text(text);
			$('.error').fadeIn().delay(5000).fadeOut();
		};

		const showCorrectedText = (res) => {
			console.log(res);

			let outString = "";
			let missedString = "";
			let deleteString = "";
			for(const pair of res.pairs){
				const isMissingPunctuation = pair[1] == null && ignore.includes(pair[0]);
				if(pair[0] != pair[1] && !isMissingPunctuation){
					if(pair[0] != null) missedString += pair[0];
					if(pair[1] != null) deleteString += pair[1];
				} else {
					if(deleteString != "") outString += '<span class="delete">' + deleteString + '</span>';
					if(missedString != "") outString += '<span class="missed">' + missedString + '</span>';
					deleteString = "";
					missedString = "";
					outString += pair[0];
				}
			}
			if(deleteString != "") outString += '<span class="delete">' + deleteString + '</span>';
			if(missedString != "") outString += '<span class="missed">' + missedString + '</span>';
			$('#output-text').show();
			$("#output-text").html(outString + " [" + Math.round(100 * res.score) + "%]");

			if(res.error){
				showError(res.error);
			}

			$("#answer-text-container").show();

			state = DoneState;
		};

		const getVerifiedPronunciation = (text, message, callback) => {
			if(!text) {
				console.error("Can't get pronunciation for null or empty text.");
				return;
			}

			$.get('/furigana', { text: text }, (res) => {
				let reading = prompt(message, res);
				if (reading == null || reading == "") console.log("canceled reading input");
				else callback(reading);
			});
		};

		const renderFurigana = () => {
			$.get('/render-furigana', { text: '<%= fact.word %>', reading: '<%= fact.reading %>' }, (res) => {
				$('.response-input').hide();
				$('#output-text').show();
				$("#output-text").html(res);
				state = DoneState;
			});
		};

		const startRecording = () => {
			speechRecognizer.setTargetPhrase('<%= fact.word %>');
			speechRecognizer.startRecording(() => { 
				console.log('end');
				console.log({ id: targetId, type: 's', results: results });
				const outResults = [];
				for(let i = 0; i < results.length; i++){
					outResults.push(results[i].transcript);
				}

				const reviewData =  { 
	    			deck: '<%= deck %>', 
	    			id: targetId,
	    			scoreType: 'speech',
	    			speechResults: outResults,
	    			original: originalText, 
	    			word: '<%= fact.word %>',
	    			reading: '<%= fact.reading %>',
	    			duration: new Date().getTime() - start, 
	    			debug: <%= debug %>, 
	    			type: '<%= options.promptType == 'audio-cloze' ? 'rw' : 'rs' %>',
	    			promptType: '<%= options.promptType %>',
	    			source: '<%= options.source || 'normal' %>',
	    			clozeWord: clozeWord,
	    			scoringMethod: '<%= scoringMethod %>',
	    			skipStreakUpdate: <%= options.skipStreakUpdate == true || options.skipStreakUpdate == 'true' %>,
	    			tries: tries
	    		};

				$.post('/review', reviewData, (res) => {
					if(res.score >= 0.99) setCorrectColor();
					else setWrongColor();

					$("#speech-out").toggleClass('partial', false);
					$("#mic-button").toggleClass('recording', false);
					if(res.score == 0){
						$("#mic-button").attr('disabled', false);
					}

					if(res.hasTries){
						$('input').attr('disabled', false);
						$('input').focus();
						$('input').select();
						state = BeginSpeech;
					} else {
						$("#continue").show();
						renderFurigana();
					}
					tries--;
				});
			});
		};

		const trimFurigana = (surface, reading) => {
			while(reading.length > 0 && reading[reading.length - 1] == surface[surface.length - 1]){
				reading = reading.slice(0, -1);
				surface = surface.slice(0, -1);
			}
			return reading;
		};

		const stateEnterHandlers = [
			() => { // beginInput
				<% if(options.promptType == 'text') {%>
				$("#original-text").hide();
				$("#begin-band").hide();
				$('.response-input').show();
				$('.response-input').focus();

				state = AfterBeginInput;		
				<% } else if(options.promptType == 'word-by-word') { %>
				if(chunkIndex < chunks.length){
					$("#original-text-container").html(chunks[chunkIndex]);

					if(chunkReadStart){
						chunkReadTimes.push(new Date().getTime() - chunkReadStart);
					}
					chunkReadStart = new Date().getTime();

					chunkIndex++;
				} else {
					chunkReadTimes.push(new Date().getTime() - chunkReadStart);

					let timedWords = [];
					let timedChunksHtml = '<ruby>';
					for(let i = 0; i < chunks.length; i++){
						timedChunksHtml += `<rb>&nbsp;${chunks[i]}&nbsp;</rb><rt>${chunkReadTimes[i]}</rt>`;
						timedWords.push({ word: chunks[i], time: chunkReadTimes[i] });
					}
					timedChunksHtml += '</ruby>';
					$('#answer-text-container').html(timedChunksHtml);
					
					timedWords.sort((a, b) => {
						return b.time - a.time;
					});
					console.log(timedWords);
					timedWords = timedWords.slice(0, 3);
					console.log(timedWords);
					targetWord = timedWords[Math.floor(timedWords.length * Math.random())];

					let blankedTextHtml = '<ruby>';
					for(let i = 0; i < chunks.length; i++){
						if(chunks[i] == targetWord.word){
							blankedTextHtml += `<rb>&nbsp;____&nbsp;</rb><rt></rt>`;
						} else {
							let reading = trimFurigana(chunks[i], chunkToReading[chunks[i]]);
							blankedTextHtml += `<rb>&nbsp;${chunks[i]}&nbsp;</rb><rt style="text-align:left">&nbsp;&nbsp;${reading}</rt>`;
						}
					}
					blankedTextHtml += '</ruby>';
					$('#blanked-text').html(blankedTextHtml);

					$("#begin-band").hide();
					$("#original-text").hide();
					$("#blanked-text").show();
					$('.response-input').show();
					$('.response-input').focus();

					state = AfterBeginInput;
				}
				<% } else { %>
				state = AwaitingAudioState;
				const audio = new Audio('/audio/<%- fact.audio %>');
				$("#begin-band").hide();
				audio.addEventListener("ended", function(){
					$("#original-text").hide();
					$("#blanked-text").show();
					$('.response-input').show();
					$('.response-input').focus();

					state = AfterBeginInput;
				});
				audio.play();
				<% } %>
			},
			() => { // submitInput
				if($("input").length > 0){
					const input = $('input').val();

	        		$('input').attr('disabled', true);

	        		state = SubmitInput;

	        		const reviewData =  { 
	        			deck: '<%= deck %>', 
	        			id: targetId, 
	        			input: input, 
	        			original: originalText, 
	        			duration: new Date().getTime() - start, 
	        			debug: <%= debug %>, 
	        			type: '<%= options.promptType == 'audio-cloze' ? 'rw' : 'rs' %>',
	        			promptType: '<%= options.promptType %>',
	        			source: '<%= options.source || 'normal' %>',
	        			clozeWord: clozeWord,
	        			scoringMethod: '<%= scoringMethod %>',
	        			skipStreakUpdate: <%= options.skipStreakUpdate == true || options.skipStreakUpdate == 'true' %>,
	        			tries: tries
	        		};

	        		const postReview = () => {
	        			$.post('/review', reviewData, (res) => {
							<% if(options.promptType == 'audio-cloze') { %>
							if(!res.hasTries) renderFurigana();
							<% } else { %>
							showCorrectedText(res);
							<% } %>

							<% if(options.giveFeedback){ %>
							if(res.score >= 0.99) setCorrectColor();
							else setWrongColor();
							<% } else { %>
							$("body").css('background-color', 'lightblue');
							<% } %>

							if(res.hasTries){
								$('input').attr('disabled', false);
								$('input').focus();
								$('input').select();
								state = BeginInput;
							} else {
								$("#continue").show();
							}
							tries--;
						});
	        		};

	        		<% if(!options.hasSentenceReading && options.promptType != 'audio-cloze') { %>
	        		$("#answer-text-container").show();
	        		getVerifiedPronunciation('<%= fact.sentence %>', 'Enter the reading for this sentence:', (reading) => {
	        			$.post('/sentence-reading', { id: targetId, sentenceReading: reading }, () => {
	        				postReview();
	        			});
	        		});
	        		<% } else { %>
					postReview();
					<% } %>
	        	}
			},
			() => { // awaitSubmitResponse
				showError("Please wait while the submission completes.");
			},
			() => {
				showError("Please wait for the audio to finish playing.");
			},
			() => {
				location.reload();
			},
			() => {
				startRecording();
				state = AwaitingSpeech;
			},
			() => {

			}
		];

		const updateSentenceChunks = () => {
			$.get('/sentence-chunks', { text: '<%= fact['sentence-reading'] %>', id: targetId }, (res) => {
				let chunks = prompt('<%= fact.sentence %>\nEnter the chunks for this sentence:', res);
				if (chunks == null || chunks == "") {
					console.log("canceled reading input");
				} else {
					$.post('/sentence-chunks', { id: targetId, sentenceChunks: chunks }, () => {
	    				location.reload();
	    			});
				}
			});
		};

		$(document).ready(() => {
			<% if(options.requireChunks && !fact['sentence-chunks']) { %>
			updateSentenceChunks();
			<% } %>

			$("#update-sentence-chunks").click(updateSentenceChunks);

			const textInput = document.querySelector('input');
			wanakana.bind(textInput);
			$('.response-input').hide();
			$('#output-text').hide();

			$(document).keypress((e) => {
	        	console.log(e.which);
	        	if(e.which == 13 || e.which == 32) {
	        		stateEnterHandlers[state]();
				}
			});

			$("#begin-input").click(() => {
				stateEnterHandlers[state]();
			});


			$("#mic-button").click(() => {
				if(new Date().getTime() - start > 5 * 60 * 1000) start = new Date().getTime();
				
				startRecording();
			});

			console.log('sel tools hook');
			selectionToolsReady((selectionTools) => {
				console.log(selectionTools);
				selectionTools.html("<button id='create-respeak-button'><%= deck == 'respeak' ? '✎' : '+' %>respeak</button>");

				$('#create-respeak-button').click(() => { 
			        let inputPhrase = prompt("Target for:\n<%= fact.sentence || fact.context %>", window.getSelection().toString());
			        if(!inputPhrase) return;
			        $.get('/furigana?text=' + inputPhrase, (reading) => {
			        	let inputReading = prompt("Reading for:\n" + inputPhrase, reading);
			        	if(!inputReading) return;
			        	const route = '<%= deck == 'respeak' ? '/update-respeak-fact' : '/create-respeak-fact' %>';
			        	$.post(route,  { word: inputPhrase, deck: "<%= deck %>", reading: inputReading, id: targetId }, (res) => {
				        	console.log(res);
				        });
			        });
			    });
			});

			// $("#continue").show();
		});
	</script>
</head>
<body>
	<% if(!options.noImage && fact.image) { %>
	<%- include('partial/recall-review-image-content', { reviewProgress: reviewProgress }) %>
	<% } else { %>
	<%- include('partial/recall-review-band-content', { reviewProgress: reviewProgress }) %>
	<% } %>
</body>
</html>