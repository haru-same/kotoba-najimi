<%
function precisionRound(number, precision) {
	var factor = Math.pow(10, precision);
	return Math.round(number * factor) / factor;
}

const average = (arr) => {
	let sum = 0;
	for(const val of arr){
		sum += val;
	}
	return sum / arr.length;
};

const timeToDayString = (time) => {
	return precisionRound(time / (1000*60*60*24), 1) + 'd';
}

const timeToHoursString = (time) => {
	return precisionRound(time / (60 * 60 * 1000), 1) + 'h';
}

const timeToSecondsString = (time) => {
	return precisionRound(time / 1000, 1) + 's';
}

const toPercent = (num) => {
	if(num !== num) return null;
	return (Math.round(1000 * num) / 10) + '%';
}

// console.log('test');
const audioCards = {
	speaking0: {},
	typing0: {},
	listening: {},
	speaking: {},
	clozeExpListening: {},
	clozeExpSpeaking: {},
	cloze: {}
};

for(const id in facts){
	const state = { knowReading: false, knowMeaning: false };

	if(facts[id].type && facts[id].type == 1 && reviewStates[id]){
		if(reviewStates[id].condition != null) {
			switch(reviewStates[id].condition){
			case 0:
				audioCards.typing0[id] = state;
				break;
			case 1:
				audioCards.speaking0[id] = state;
				break;
			}
		}
	}

	if(facts[id].type && facts[id].type == 3 && reviewStates[id]){
		if(reviewStates[id].condition == null && reviewStates[id].experiments && reviewStates[id].experiments['listen-speak-cloze'] != null) {
			switch(reviewStates[id].experiments['listen-speak-cloze']){
			case 0:
				audioCards.clozeExpListening[id] = state;
				audioCards.listening[id] = state;
				break;
			case 1:
				audioCards.clozeExpSpeaking[id] = state;
				audioCards.speaking[id] = state;
				break;
			case 2:
				audioCards.cloze[id] = state;
				break;
			}
		} else if(reviewStates[id].condition != null) {
			switch(reviewStates[id].condition){
			case 0:
				audioCards.listening[id] = state;
				break;
			case 1:
				audioCards.speaking[id] = state;
				break;
			}
		}
	}
}

const learnedReading = {};
const forgotReading = {};
const learnedMeaning = {};
const forgotMeaning = {};

const readingKnown = {};
const meaningKnown = {};

const slices = [ 'speaking0', 'typing0', 'listening', 'speaking', 'clozeExpListening', 'clozeExpSpeaking', 'cloze', 'withImage', 'withoutImage' ];

const streakToDescription = { "-1": "Just got it wrong", 0: "New or just fixed" };
for(let i = 1; i < 10; i++){
	streakToDescription[i] = Math.pow(2, i - 1) + " days old";
}

const streakCounts = {};
for(const streak in streakToDescription){
	streakCounts[streak] = { count: 0 };
	for(const totalCorrect of ['total', 'correct']){
		streakCounts[streak][totalCorrect] = {};
		for(const slice of slices){
			streakCounts[streak][totalCorrect][slice] = 0;
		}
	}
}

const counts = {};
for(const countType of [ 'text-inverted-cloze', 'audio-inverted-cloze', 'meaning', 'reading', 'listen-meaning-0', 'listen-meaning-1', 'newcloze' ]){
	counts[countType] = { count: 0 };
	for(const totalCorrect of ['total', 'correct']){
		counts[countType][totalCorrect] = {};
		for(const slice of slices){
			counts[countType][totalCorrect][slice] = 0;
		}
	}
}

const timeCounts = {};
for(const countType of ['reviewDuration', 'listen-meaning-0', 'listen-meaning-1', 'text-inverted-cloze', 'audio-inverted-cloze' ]){
	timeCounts[countType] = { };
	for(const countTime of ['count', 'time']){
		timeCounts[countType][countTime] = {};
		for(const slice of slices){
			timeCounts[countType][countTime][slice] = 0;
		}
	}
}

const staticCounts = {};
for(const countType of ['meaningKnown', 'readingKnown', 'forgotMeaning', 'forgotReading']){
	staticCounts[countType] = { };
	for(const slice of slices){
		staticCounts[countType][slice] = 0;
	}
}
console.log(staticCounts);

// const getReviewType = (logEntry) => {
// 	const reviewType = { base: "", sub: "" };
// 	const 
// };

const addToCount = (logType, id, result, countSet) => {
	countSet = countSet || counts;

	countSet[logType].count++;

	for(const key in audioCards){
		if(audioCards[key][id]){
			countSet[logType].total[key]++;
			if(result) countSet[logType].correct[key]++;
		}
	}

	if(facts[id] && facts[id].image && facts[id].type == 3 && parseInt(facts[id].created) > 1522209600000){
		if(reviewStates[id]['image-condition'] == 1){
			countSet[logType].total.withImage++;
			if(result) countSet[logType].correct.withImage++;
		} else if(reviewStates[id]['image-condition'] == 0){
			countSet[logType].total.withoutImage++;
			if(result) countSet[logType].correct.withoutImage++;
		}
	}
};

const addToTimeCount = (logType, id, time) => {
	if(time > 60*1000) return;

	for(const key in audioCards){
		if(audioCards[key][id]){
			timeCounts[logType].count[key]++;
			timeCounts[logType].time[key] += time;
		}
	}

	if(facts[id] && facts[id].image && facts[id].type == 3 && parseInt(facts[id].created) > 1522209600000){
		if(reviewStates[id]['image-condition'] == 1){
			timeCounts[logType].count.withImage++;
			timeCounts[logType].time.withImage += time;
		} else if(reviewStates[id]['image-condition'] == 0){
			timeCounts[logType].count.withoutImage++;
			timeCounts[logType].time.withoutImage += time;
		}
	}
};

const addToStaticCount = (logType, id) => {
	for(const key in audioCards){
		if(audioCards[key][id]) staticCounts[logType][key]++;
	}

	if(facts[id] && facts[id].image && facts[id].type == 3 && parseInt(facts[id].created) > 1522209600000){
		if(reviewStates[id]['image-condition'] == 1){
			staticCounts[logType].withImage++;
		} else if(reviewStates[id]['image-condition'] == 0){
			staticCounts[logType].withoutImage++;
		}
	}
};

for(const id in reviewStates){
	addToCount(reviewStates[id].streak, id, 0, streakCounts);
}

for(const logEntry of reviewLogs){
	if(!logEntry.message.id) continue;

	const id = logEntry.message.id;
	let result = 0;
	if(logEntry.message.result == 1 || logEntry.message.score == 1){
		result = 1;
	} 

	if(logEntry.message.duration){
		const duration = parseInt(logEntry.message.duration);
		let type = "reviewDuration";
		switch(logEntry.message.type){
		case "listening-meaning":
			if(logEntry.message.streak == null || parseInt(logEntry.message.streak) >= 3)
				type = 'listen-meaning-1';
			else 
				type = 'listen-meaning-0';
			break;
		case "inverted-cloze":
			switch(logEntry.message.promptType){
			case 'text':
				type = 'text-inverted-cloze';
				break;
			case 'audio':
				type = 'audio-inverted-cloze';
				break;
			} 
			break;
		}
		addToTimeCount(type, id, duration);
	}

	if(logEntry.message.tries == "1" && logEntry.message.result == 0) continue;

	if(logEntry.message.type == 'meaning'){
		addToCount('meaning', id, result);

		if(result == 1){
			learnedMeaning[id] = true;
			meaningKnown[id] = true;
		}

		if(result == 0 && learnedMeaning[id]){
			meaningKnown[id] = false;
			forgotMeaning[id] = true;
			console.log(id);
		}
	}

	if(logEntry.message.type == 'listening-meaning'){
		console.log('streak: ' + logEntry.message.streak, (logEntry.message.streak == null || parseInt(logEntry.message.streak) >= 3) == true);
		if(logEntry.message.streak == null || parseInt(logEntry.message.streak) >= 3)
			addToCount('listen-meaning-1', id, result);
		else 
			addToCount('listen-meaning-0', id, result);
	} 

	if(logEntry.message.type == 'fresh-cloze'){
		addToCount('newcloze', id, result);
	} 

	if(logEntry.message.streak == 3 && logEntry.message.type == 'kanji' && (audioCards.listening[id] || audioCards.speaking[id])){
		addToCount('reading', id, result);

		if(result == 1){
			learnedReading[id] = true;
			readingKnown[id] = true;
		}
	}

	const isReadingEntry = logEntry.message.type == 'kanji' || logEntry.message.type == 'recall';
	if(result == 0 && learnedReading[id] && isReadingEntry){
		readingKnown[id] = false;
		forgotReading[id] = true;
	}

	if(logEntry.message.type == 'inverted-cloze'){
		switch(logEntry.message.promptType){
		case 'text':
			addToCount('text-inverted-cloze', id, result);
			break;
		case 'audio':
			addToCount('audio-inverted-cloze', id, result);
			break;
		} 
	}
}

const countsTableHeader = [''];
for(const slice of slices) {
	countsTableHeader.push(slice);
}

const streakCountsTable = [countsTableHeader];
for(let i = -1; i < 9; i++) {
	const row = [];
	row.push(streakToDescription[i]);
	for(const slice of slices){
		row.push(streakCounts[i].total[slice]);
	}
	streakCountsTable.push(row);
}

const countsTable = [countsTableHeader];
for(const key1 in counts) {
	const row = [];
	row.push(key1);
	for(const slice of slices){
		const percent = toPercent(counts[key1].correct[slice]/counts[key1].total[slice]);
		if(percent){
			row.push(`${percent} (${counts[key1].correct[slice]}/${counts[key1].total[slice]})`);
		} else {
			row.push(`-`);
		}
	}
	countsTable.push(row);
}

const timeCountsTable = [countsTableHeader];
for(const key1 in timeCounts) {
	const row = [];
	row.push(key1);
	for(const slice of slices){
		if(timeCounts[key1].count[slice] == 0){
			row.push(`-`);
		} else {
			const duration = timeToHoursString(timeCounts[key1].time[slice]);
			const averageTime = timeToSecondsString(timeCounts[key1].time[slice]/timeCounts[key1].count[slice]);
			row.push(`${duration}<br>(${timeCounts[key1].count[slice]}, avg. ${averageTime})`);
		}
	}
	timeCountsTable.push(row);
}

for(const id in forgotReading) addToStaticCount('forgotReading', id);
for(const id in forgotMeaning) addToStaticCount('forgotMeaning', id);
for(const id in readingKnown) if(readingKnown[id]) addToStaticCount('readingKnown', id);
for(const id in meaningKnown) if(meaningKnown[id]) addToStaticCount('meaningKnown', id);

const staticCountsTable = [countsTableHeader];
for(const key in staticCounts) {
	const row = [];
	row.push(key);
	for(const slice of slices){
		row.push(staticCounts[key][slice]);
	}
	staticCountsTable.push(row);
}
%>
<table>
	<% for(const row of streakCountsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%= item %></td>
		<%}%>
	</tr>
	<% } %>
</table>
<br><br>
<table>
	<% for(const row of countsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%= item %></td>
		<%}%>
	</tr>
	<% } %>
	</tr>
</table>
<br><br>
<table>
	<% for(const row of timeCountsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%- item %></td>
		<%}%>
	</tr>
	<% } %>
</table>
<br><br>
<table>
	<% for(const row of staticCountsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%= item %></td>
		<%}%>
	</tr>
	<% } %>
</table>