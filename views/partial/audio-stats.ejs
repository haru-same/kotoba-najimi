<%
const twoProportionZTest = (counts1, counts2) => {
	const p1 = counts1.correct / counts1.total;
	const p2 = counts2.correct / counts2.total;
	const ph = (counts1.correct + counts2.correct) / (counts1.total + counts2.total);
	const oneOverN1 = 1 / counts1.total;
	const oneOverN2 = 1 / counts2.total;
	const value = (p2 - p1) / Math.sqrt(ph * (1 - ph) * (oneOverN1 + oneOverN2));
	console.log(counts1, counts2, value);
	return value;
};

const getSignificanceStars = (zValue) => {
	zValue = Math.abs(zValue);
	console.log(zValue);
	if(zValue > 3.2905267283){
		return '***';
	} else if(zValue > 2.5758293064) {
		return '**';
	} else if(zValue > 1.9599639861) {
		return '*';
	} else {
		return '';
	}
};

const getSignificanceString = (measure, slice1, slice2) => {
	return getSignificanceStars(twoProportionZTest(getProportionSet(measure, slice1), getProportionSet(measure, slice2)));
};

const getProportionSet = (measure, slice) => {
	return {
		correct: counts[measure].correct[slice],
		total: counts[measure].total[slice],
	};
};

const  precisionRound = (number, precision) => {
	var factor = Math.pow(10, precision);
	return Math.round(number * factor) / factor;
};

const average = (arr) => {
	let sum = 0;
	for(const val of arr){
		sum += val;
	}
	return sum / arr.length;
};

const timeToDayString = (time) => {
	return precisionRound(time / (1000*60*60*24), 1) + 'd';
}

const timeToHoursString = (time) => {
	return precisionRound(time / (60 * 60 * 1000), 1) + 'h';
}

const timeToSecondsString = (time) => {
	return precisionRound(time / 1000, 1) + 's';
}

const toPercent = (num) => {
	if(num !== num) return null;
	return (Math.round(1000 * num) / 10) + '%';
}

// console.log('test');
const audioCards = {
	speaking0: {},
	typing0: {},
	listening: {},
	speaking: {},
	clozeExpListening: {},
	clozeExpSpeaking: {},
	cloze: {}
};

for(const id in facts){
	const state = { knowReading: false, knowMeaning: false };

	// console.log(facts[id]);

	if(facts[id].type && facts[id].type == 1 && reviewStates[id]){
		if(reviewStates[id].condition != null) {
			switch(reviewStates[id].condition){
			case 0:
				audioCards.typing0[id] = state;
				break;
			case 1:
				audioCards.speaking0[id] = state;
				break;
			}
		}
	}

	if(facts[id].type && facts[id].type == 3 && reviewStates[id]){
		if(reviewStates[id].condition == null && reviewStates[id].experiments && reviewStates[id].experiments['listen-speak-cloze'] != null) {
			switch(reviewStates[id].experiments['listen-speak-cloze']){
			case 0:
				audioCards.clozeExpListening[id] = state;
				audioCards.listening[id] = state;
				break;
			case 1:
				audioCards.clozeExpSpeaking[id] = state;
				audioCards.speaking[id] = state;
				break;
			case 2:
				audioCards.cloze[id] = state;
				break;
			}
		} else if(reviewStates[id].condition != null) {
			switch(reviewStates[id].condition){
			case 0:
				audioCards.listening[id] = state;
				break;
			case 1:
				audioCards.speaking[id] = state;
				break;
			}
		}
	}
}

// console.log(audioCards);

const learnedReading = {};
const forgotReading = {};
const learnedMeaning = {};
const forgotMeaning = {};

const readingKnown = {};
const meaningKnown = {};

const slices = [ 'speaking0', 'typing0', 'listening', 'speaking', 'clozeExpListening', 'clozeExpSpeaking', 'cloze', 'withImage', 'withoutImage' ];

const streakToDescription = { "-1": "Just got it wrong", 0: "New or just fixed" };
for(let i = 1; i < 10; i++){
	streakToDescription[i] = Math.pow(2, i - 1) + " day gap";
}

const streakCounts = {};
for(const streak in streakToDescription){
	streakCounts[streak] = { count: 0 };
	for(const totalCorrect of ['total', 'correct']){
		streakCounts[streak][totalCorrect] = {};
		for(const slice of slices){
			streakCounts[streak][totalCorrect][slice] = 0;
		}
	}
}

const counts = {};
for(const countType of [ 'accuracy', 'meaning', 'reading', 'listen-meaning-0', 'listen-meaning-1', 
	'text-inverted-internal-cloze', 'audio-inverted-internal-cloze', 'external-cloze', 'text-binary-internal-cloze', 'audio-binary-internal-cloze', 'text-binary-external-cloze', 'audio-binary-external-cloze',  ]){
	counts[countType] = { count: 0 };
	for(const totalCorrect of ['total', 'correct']){
		counts[countType][totalCorrect] = {};
		for(const slice of slices){
			counts[countType][totalCorrect][slice] = 0;
		}
	}
}

const timeCounts = {};
for(const countType of ['reviewDuration', 'listen-meaning-0', 'listen-meaning-1', 'text-inverted-internal-cloze', 'audio-inverted-internal-cloze',
	'text-binary-internal-cloze', 'audio-binary-internal-cloze', 'text-binary-external-cloze', 'audio-binary-external-cloze' ]){
	timeCounts[countType] = { };
	for(const countTime of ['count', 'time']){
		timeCounts[countType][countTime] = {};
		for(const slice of slices){
			timeCounts[countType][countTime][slice] = 0;
		}
	}
}

const staticCounts = {};
for(const countType of ['meaningKnown', 'readingKnown', 'forgotMeaning', 'forgotReading']){
	staticCounts[countType] = { };
	for(const slice of slices){
		staticCounts[countType][slice] = 0;
	}
}

const addToCount = (logType, id, result, countSet) => {
	countSet = countSet || counts;

	countSet[logType].count++;

	for(const key in audioCards){
		if(audioCards[key][id]){
			countSet[logType].total[key]++;
			if(result) countSet[logType].correct[key]++;
		}
	}

	if(facts[id] && facts[id].image && facts[id].type == 3 && parseInt(facts[id].created) > 1522209600000){
		if(reviewStates[id]['image-condition'] == 1){
			countSet[logType].total.withImage++;
			if(result) countSet[logType].correct.withImage++;
		} else if(reviewStates[id]['image-condition'] == 0){
			countSet[logType].total.withoutImage++;
			if(result) countSet[logType].correct.withoutImage++;
		}
	}
};

const addToTimeCount = (logType, id, time) => {
	if(time > 60*1000) return;

	for(const key in audioCards){
		if(audioCards[key][id]){
			timeCounts[logType].count[key]++;
			timeCounts[logType].time[key] += time;
		}
	}

	if(facts[id] && facts[id].image && facts[id].type == 3 && parseInt(facts[id].created) > 1522209600000){
		if(reviewStates[id]['image-condition'] == 1){
			timeCounts[logType].count.withImage++;
			timeCounts[logType].time.withImage += time;
		} else if(reviewStates[id]['image-condition'] == 0){
			timeCounts[logType].count.withoutImage++;
			timeCounts[logType].time.withoutImage += time;
		}
	}
};

const addToStaticCount = (logType, id) => {
	for(const key in audioCards){
		if(audioCards[key][id]) staticCounts[logType][key]++;
	}

	if(facts[id] && facts[id].image && facts[id].type == 3 && parseInt(facts[id].created) > 1522209600000){
		if(reviewStates[id]['image-condition'] == 1){
			staticCounts[logType].withImage++;
		} else if(reviewStates[id]['image-condition'] == 0){
			staticCounts[logType].withoutImage++;
		}
	}
};

for(const id in reviewStates){
	addToCount(reviewStates[id].streak, id, 0, streakCounts);
}

console.log('logcount:', reviewLogs.length);

for(const logEntry of reviewLogs){
	if(!logEntry.message.id) continue;

	const id = logEntry.message.id;
	const isTraining = logEntry.message.type == 'kanji' || logEntry.message.type == 'recall';
	const result = logEntry.message.result == 1 || logEntry.message.score == 1 ? 1 : 0;

	if(isTraining){
		if(logEntry.message.duration){
			const duration = parseInt(logEntry.message.duration);
			if(logEntry.message.type == 'kanji' 
				|| (logEntry.message.type == 'recall' && logEntry.message.source != 'daily-recall')){
				addToTimeCount("reviewDuration", id, duration);
			}
		}

		if(logEntry.message.tries == "1" && logEntry.message.result == 0) continue;
		addToCount('accuracy', id, result);

		if(logEntry.message.streak == 3 && logEntry.message.type == 'kanji' && (audioCards.listening[id] || audioCards.speaking[id])){
			addToCount('reading', id, result);

			if(result == 1){
				learnedReading[id] = true;
				readingKnown[id] = true;
			}
		}
		
		if(result == 0 && learnedReading[id]){
			readingKnown[id] = false;
			forgotReading[id] = true;
		}
	} else {
		let statType = null;
		let doDuration = false;
		switch(logEntry.message.type){
		case 'meaning':
			statType = 'meaning';

			if(result == 1){
				learnedMeaning[id] = true;
				meaningKnown[id] = true;
			}

			if(result == 0 && learnedMeaning[id]){
				meaningKnown[id] = false;
				forgotMeaning[id] = true;
			}
			break;
		case 'external-cloze':
			statType ='external-cloze';
			break;
		case 'listening-meaning':
			if(logEntry.message.streak == null || parseInt(logEntry.message.streak) >= 3)
				statType = 'listen-meaning-1';
			else 
				statType = 'listen-meaning-0';
			doDuration = true;
			break;
		case 'inverted-cloze':
			switch(logEntry.message.promptType){
			case 'text':
				statType = 'text-inverted-internal-cloze';
				break;
			case 'audio':
				statType = 'audio-inverted-internal-cloze';
				break;
			}
			doDuration = true;
			break;
		case 'binary-internal-cloze':
			switch(logEntry.message.promptType){
			case 'text':
				statType = 'text-binary-internal-cloze';
				break;
			case 'audio':
				statType = 'audio-binary-internal-cloze';
				break;
			} 
			doDuration = true;
			break;
		case 'binary-external-cloze':
			switch(logEntry.message.promptType){
			case 'text':
				statType = 'text-binary-external-cloze';
				break;
			case 'audio':
				statType = 'audio-binary-external-cloze';
				break;
			} 
			doDuration = true;
			break;
		}	

		// if(!Array.isArray())
		if(statType){
			addToCount(statType, id, result);
			if(doDuration && logEntry.message.duration){
				const duration = parseInt(logEntry.message.duration);
				addToTimeCount(statType, id, duration);
			}
		}
	}
}

const countsTableHeader = [''];
for(const slice of slices) {
	countsTableHeader.push(slice);
}

const streakCountsTable = [countsTableHeader];
for(let i = -1; i < 9; i++) {
	const row = [];
	row.push(streakToDescription[i]);
	for(const slice of slices){
		row.push(streakCounts[i].total[slice]);
	}
	streakCountsTable.push(row);
}

const countsTable = [countsTableHeader];
for(const key1 in counts) {
	const row = [];
	row.push(key1);
	for(const slice of slices){
		const percent = toPercent(counts[key1].correct[slice]/counts[key1].total[slice]);
		if(percent){
			let significanceString = "";

			if(slice == "speaking0"){
				significanceString = getSignificanceString(key1, "typing0", "speaking0");
			}
			if(slice == "typing0") {
				significanceString = getSignificanceString(key1, "typing0", "speaking0");
			}

			if(slice == "listening"){
				significanceString = getSignificanceString(key1, "listening", "speaking");
			}
			if(slice == "speaking") {
				significanceString = getSignificanceString(key1, "listening", "speaking");
			}

			if(slice == "withImage"){
				significanceString = getSignificanceString(key1, "withImage", "withoutImage");
			}
			if(slice == "withoutImage") {
				significanceString = getSignificanceString(key1, "withImage", "withoutImage");
			}

			let output = `${percent}${significanceString} (${counts[key1].correct[slice]}/${counts[key1].total[slice]})`;
			if(significanceString) output = `<b>${output}</b>`;
			row.push(output);
		} else {
			row.push(`-`);
		}
	}
	countsTable.push(row);
}

const timeCountsTable = [countsTableHeader];
for(const key1 in timeCounts) {
	const row = [];
	row.push(key1);
	for(const slice of slices){
		if(timeCounts[key1].count[slice] == 0){
			row.push(`-`);
		} else {
			const duration = timeToHoursString(timeCounts[key1].time[slice]);
			const averageTime = timeToSecondsString(timeCounts[key1].time[slice]/timeCounts[key1].count[slice]);
			row.push(`${duration}<br>(${timeCounts[key1].count[slice]}, avg. ${averageTime})`);
		}
	}
	timeCountsTable.push(row);
}

for(const id in forgotReading) addToStaticCount('forgotReading', id);
for(const id in forgotMeaning) addToStaticCount('forgotMeaning', id);
for(const id in readingKnown) if(readingKnown[id]) addToStaticCount('readingKnown', id);
for(const id in meaningKnown) if(meaningKnown[id]) addToStaticCount('meaningKnown', id);

const staticCountsTable = [countsTableHeader];
for(const key in staticCounts) {
	const row = [];
	row.push(key);
	for(const slice of slices){
		row.push(staticCounts[key][slice]);
	}
	staticCountsTable.push(row);
}
%>
<table>
	<% for(const row of streakCountsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%= item %></td>
		<%}%>
	</tr>
	<% } %>
</table>
<br><br>
<table>
	<% for(const row of countsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%- item %></td>
		<%}%>
	</tr>
	<% } %>
	</tr>
</table>
<br><br>
<table>
	<% for(const row of timeCountsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%- item %></td>
		<%}%>
	</tr>
	<% } %>
</table>
<br><br>
<table>
	<% for(const row of staticCountsTable){%>
	<tr>
		<% for(const item of row){%>
		<td><%= item %></td>
		<%}%>
	</tr>
	<% } %>
</table>
<br>
listening-meaning0, speech/listening: <%= getSignificanceString('listen-meaning-0', 'listening', 'speaking') %><br>
listening-meaning1, speech/listening: <%= getSignificanceString('listen-meaning-1', 'listening', 'speaking') %><br>